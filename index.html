<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Neon Civil Dashboard - Professional Theme</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    /* New Professional Theme Colors */
    :root {
      --color-primary-bg: #1A202C; /* Deep dark blue/gray */
      --color-secondary-bg: #2D3748; /* Slightly lighter dark blue/gray */
      --color-card-bg: #151A21; /* Rich dark dark/black for articles/modal */
      --color-task-base-bg: #2A3342; /* Deeper dark blue for task cards */
      --color-text-light: #E2E8F0; /* Off-white/light gray */
      --color-text-medium: #CBD5E0; /* Slightly darker light gray */
      --color-accent-teal: #4FD1C5; /* Muted modern teal (kept for overall accents) */
      --color-accent-blue: #63B3ED; /* For in progress/medium priority */
      --color-accent-orange: #F6AD55; /* For pending/high priority */
      --color-accent-red: #E53E3E; /* For overdue/critical */

      --color-success: #4FD1C5;
      --color-warning: #F6AD55;
      --color-danger: #E53E3E;

      /* Progress bar colors based on priority */
      --color-progress-high: #E53E3E;
      --color-progress-medium: #ECC94B;
      --color-progress-low: #48BB78; /* A nice green */
    }

    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      background-color: var(--color-primary-bg);
      color: var(--color-text-light);
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      background-color: var(--color-secondary-bg);
      padding: 1.5rem 2rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      color: var(--color-text-light);
      font-weight: 700;
      font-size: 1.8rem;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .header-controls input[type="search"],
    .header-controls select {
      padding: 0.6rem 1rem;
      border: 1px solid var(--color-secondary-bg);
      border-radius: 6px;
      background-color: var(--color-card-bg);
      color: var(--color-text-light);
      font-size: 0.9rem;
      appearance: none; /* Remove default arrow for select */
    }

    .header-controls select {
        padding-right: 2.5rem; /* Make space for custom arrow if needed */
        background-image: url('data:image/svg+xml;utf8,<svg fill="%23E2E8F0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
        background-repeat: no-repeat;
        background-position: right 0.7rem top 50%;
        background-size: 1rem auto;
    }

    .export-button {
      background-color: var(--color-accent-teal);
      color: var(--color-primary-bg);
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .export-button:hover {
      background-color: #38B2AC; /* Slightly darker teal */
    }

    main {
      flex-grow: 1;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    .dashboard-summary {
      display: flex;
      justify-content: space-around;
      gap: 1.5rem;
      flex-wrap: wrap;
    }

    .summary-card {
      background-color: var(--color-secondary-bg);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      flex: 1;
      min-width: 200px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .summary-card h2 {
      margin-top: 0;
      font-size: 1rem;
      color: var(--color-text-medium);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .summary-card p {
      margin-bottom: 0;
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--color-accent-teal);
    }
    .summary-card p.overdue {
        color: var(--color-accent-red);
    }
    .summary-card p.progress-text {
        font-size: 1.2rem;
        color: var(--color-text-light);
    }


    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
    }

    .chart-card {
      background-color: var(--color-secondary-bg);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      min-height: 250px; /* Ensure charts have space */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .chart-card h2 {
      margin-top: 0;
      color: var(--color-text-light);
      font-size: 1.2rem;
      margin-bottom: 1rem;
    }

    .chart-canvas-container {
      position: relative;
      width: 100%;
      height: 200px; /* Fixed height for consistent chart size */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .task-columns {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
    }

    article {
      background-color: var(--color-secondary-bg);
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-height: 300px; /* Ensure columns have a minimum height */
      transition: background-color 0.2s ease;
    }

    article.drag-over {
      background-color: var(--color-card-bg); /* Darker background on drag over */
      border: 2px dashed var(--color-accent-teal);
    }

    article h2 {
      margin-top: 0;
      color: var(--color-text-light);
      font-size: 1.4rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .add-task-inline {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .add-task-inline input {
      flex-grow: 1;
      padding: 0.5rem 1rem;
      border: 1px solid var(--color-secondary-bg);
      border-radius: 4px;
      background-color: var(--color-card-bg);
      color: var(--color-text-light);
      font-size: 0.9rem;
    }

    .add-task-inline button {
      background-color: var(--color-accent-teal);
      color: var(--color-primary-bg);
      border: none;
      border-radius: 4px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-weight: 600;
      transition: background-color 0.2s ease;
    }

    .add-task-inline button:hover {
      background-color: #38B2AC;
    }

    .task-card {
      background-color: var(--color-task-base-bg);
      border-radius: 6px;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      border-left: 5px solid var(--color-accent-blue); /* Default border color */
      cursor: grab;
      transition: all 0.2s ease-in-out;
      display: flex;
      flex-direction: column;
      justify-content: space-between; /* Pushes meta to bottom */
      min-height: 120px;
      position: relative; /* For pop-out animation */
    }

    .task-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
    }

    .task-card h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      color: var(--color-text-light);
      font-size: 1.1rem;
    }

    .task-card .task-description {
      color: var(--color-text-medium);
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }
    .task-card .task-notes {
        font-size: 0.8em;
        color: var(--color-text-medium);
        margin-top: -0.2em;
        margin-bottom: 0.5em;
        border-top: 1px dashed rgba(255,255,255,0.1);
        padding-top: 0.5em;
    }


    /* Priority border colors */
    .task-card.High { border-left-color: var(--color-progress-high); }
    .task-card.Medium { border-left-color: var(--color-progress-medium); }
    .task-card.Low { border-left-color: var(--color-progress-low); }

    .task-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 10px;
        margin-bottom: 0.5rem;
    }
    .task-header h3 {
        flex-grow: 1;
        margin: 0;
    }
    .task-actions {
        display: flex;
        gap: 5px;
    }
    .icon-button {
        background: none;
        border: none;
        font-size: 1em;
        cursor: pointer;
        padding: 5px;
        border-radius: 4px;
        transition: background-color 0.2s;
        color: var(--color-text-medium);
    }
    .icon-button:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    .delete-button:hover {
        color: var(--color-danger);
    }


    .task-meta-details,
    .task-info {
      display: flex;
      flex-wrap: wrap;
      gap: 0.7rem;
      font-size: 0.75rem;
      color: var(--color-text-medium);
      margin-top: 0.5rem;
    }
    .task-info {
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 0.5rem;
        margin-top: 1rem;
        justify-content: space-between;
        align-items: flex-end; /* Align archive button to bottom-right */
    }
    .task-info .task-dates {
        display: flex;
        flex-direction: column;
        gap: 0.2em;
        font-size: 0.7em;
    }
    .task-info .last-modified {
        font-style: italic;
    }

    .task-card .task-progress-text {
        font-weight: 600;
        color: var(--color-text-light);
        flex-shrink: 0; /* Prevent it from shrinking */
    }

    .task-info button {
        background-color: var(--color-card-bg);
        color: var(--color-text-light);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7em;
        transition: background-color 0.2s ease;
    }
    .task-info button:hover {
        background-color: var(--color-primary-bg);
    }


    .task-card.overdue {
        border-left-color: var(--color-accent-red);
        background-color: rgba(229, 62, 62, 0.1); /* Light red background for overdue */
    }

    /* Modal Styles */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }
    .modal-backdrop.show {
        opacity: 1;
        display: flex;
    }
    .modal-backdrop.hide {
        opacity: 0;
    }


    .task-modal {
      background-color: var(--color-card-bg);
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      width: 90%;
      max-width: 600px;
      transform: translateY(-50px);
      opacity: 0;
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      display: none; /* Hidden by default */
      z-index: 1001;
    }

    .task-modal.show {
        opacity: 1;
        transform: translateY(0);
        display: block; /* Make it block during animation */
    }
    .task-modal.hide {
        opacity: 0;
        transform: translateY(-50px);
    }


    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 1rem;
    }

    .modal-header h2 {
      margin: 0;
      color: var(--color-text-light);
      font-size: 1.5rem;
    }

    .modal-close-button {
      background: none;
      border: none;
      font-size: 1.8rem;
      color: var(--color-text-medium);
      cursor: pointer;
      transition: color 0.2s;
    }
    .modal-close-button:hover {
      color: var(--color-text-light);
    }

    .modal-form label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--color-text-medium);
      font-size: 0.9rem;
    }

    .modal-form input[type="text"],
    .modal-form input[type="date"],
    .modal-form input[type="number"],
    .modal-form textarea,
    .modal-form select {
      width: calc(100% - 20px);
      padding: 0.8rem 10px;
      margin-bottom: 1rem;
      border: 1px solid var(--color-secondary-bg);
      border-radius: 6px;
      background-color: var(--color-secondary-bg);
      color: var(--color-text-light);
      font-size: 1rem;
      box-sizing: border-box; /* Include padding in width */
    }

    .modal-form textarea {
      resize: vertical;
      min-height: 80px;
    }
    .modal-form select {
      appearance: none;
      background-image: url('data:image/svg+xml;utf8,<svg fill="%23CBD5E0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
      background-repeat: no-repeat;
      background-position: right 10px center;
      background-size: 18px auto;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 1rem;
      margin-top: 1.5rem;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 1.5rem;
    }

    .modal-button {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    .modal-button.cancel {
      background-color: var(--color-secondary-bg);
      color: var(--color-text-light);
    }
    .modal-button.cancel:hover {
      background-color: #4A5568;
    }

    .modal-button.action {
      background-color: var(--color-accent-teal);
      color: var(--color-primary-bg);
    }
    .modal-button.action:hover {
      background-color: #38B2AC;
    }

    /* Snackbar styles */
    .snackbar {
      visibility: hidden; /* Hidden by default. Spans the whole width */
      min-width: 250px; /* Set a minimum width */
      background-color: #333; /* Black background color */
      color: #fff; /* White text color */
      text-align: center; /* Centered text */
      border-radius: 8px; /* Rounded borders */
      padding: 16px; /* Padding */
      position: fixed; /* Sit on top of the screen */
      z-index: 1; /* Add a z-index if needed */
      left: 50%; /* Center the snackbar */
      bottom: 30px; /* 30px from the bottom */
      transform: translateX(-50%);
      font-size: 0.9em;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }

    /* Show the snackbar when adding the "show" class */
    .snackbar.show {
      visibility: visible; /* Show the snackbar */
      /* Add animation: Take 0.5 seconds to fade in and out the snackbar.
      However, setting a delay for the fade-out part */
      -webkit-animation: fadein 0.5s, fadeout 0.5s 2.5s;
      animation: fadein 0.5s, fadeout 0.5s 2.5s;
    }
    .snackbar.error {
        background-color: var(--color-danger);
    }

    /* Animations for snackbar */
    @-webkit-keyframes fadein {
      from {bottom: 0; opacity: 0;}
      to {bottom: 30px; opacity: 1;}
    }

    @keyframes fadein {
      from {bottom: 0; opacity: 0;}
      to {bottom: 30px; opacity: 1;}
    }

    @-webkit-keyframes fadeout {
      from {bottom: 30px; opacity: 1;}
      to {bottom: 0; opacity: 0;}
    }

    @keyframes fadeout {
      from {bottom: 30px; opacity: 1;}
      to {bottom: 0; opacity: 0;}
    }

    /* Pop out animation for task deletion */
    @keyframes popOut {
        0% { transform: scale(1); opacity: 1; height: auto; padding: 1rem; margin-bottom: 1rem; }
        100% { transform: scale(0.5); opacity: 0; height: 0; padding: 0; margin-bottom: 0; overflow: hidden;}
    }

  </style>
</head>
<body>
  <header>
    <h1>Neon Civil Task Dashboard</h1>
    <div class="header-controls">
      <input type="search" id="searchInput" placeholder="Search tasks..." onkeyup="renderTasks()">
      <select id="categoryFilter" onchange="renderTasks()">
        <option value="">Filter by Category</option>
        <option value="Development">Development</option>
        <option value="Design">Design</option>
        <option value="Marketing">Marketing</option>
        <option value="Sales">Sales</option>
        <option value="Support">Support</option>
        <option value="Testing">Testing</option>
        <option value="General">General</option>
      </select>
      <select id="priorityFilter" onchange="renderTasks()">
        <option value="">Filter by Priority</option>
        <option value="High">High</option>
        <option value="Medium">Medium</option>
        <option value="Low">Low</option>
      </select>
      <select id="assignedToFilter" onchange="renderTasks()">
        <option value="">Filter by Assignee</option>
        </select>
      <label style="display: flex; align-items: center; gap: 0.5rem; color: var(--color-text-medium);">
          <input type="checkbox" id="showArchivedCheckbox" onchange="renderTasks()"> Show Archived
      </label>
      <button class="export-button" onclick="exportToExcel()">Export to Excel</button>
    </div>
  </header>

  <main>
    <section class="dashboard-summary">
      <div class="summary-card">
        <h2>Overall Progress</h2>
        <p id="progressMessage">Loading...</p>
      </div>
      <div class="summary-card">
        <h2>Overdue Tasks</h2>
        <p id="overdueCount" class="overdue">0</p>
      </div>
    </section>

    <section class="charts-container">
      <div class="chart-card">
        <h2>Task Status Distribution</h2>
        <div class="chart-canvas-container">
          <canvas id="taskStatusChart"></canvas>
        </div>
      </div>
      <div class="chart-card">
        <h2>Task Priority Distribution</h2>
        <div class="chart-canvas-container">
          <canvas id="taskPriorityChart"></canvas>
        </div>
      </div>
      <div class="chart-card">
        <h2>Task Category Distribution</h2>
        <div class="chart-canvas-container">
          <canvas id="taskCategoryChart"></canvas>
        </div>
      </div>
    </section>

    <section class="task-columns">
      <article id="Pending" ondrop="drop(event, 'Pending')" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
        <h2>Pending</h2>
        <div class="add-task-inline">
            <input type="text" id="pendingTaskInput" placeholder="New pending task title...">
            <button onclick="addInlineTask('Pending', 'pendingTaskInput')">Add</button>
        </div>
      </article>

      <article id="In Progress" ondrop="drop(event, 'In Progress')" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
        <h2>In Progress</h2>
        <div class="add-task-inline">
            <input type="text" id="inProgressTaskInput" placeholder="New in-progress task title...">
            <button onclick="addInlineTask('In Progress', 'inProgressTaskInput')">Add</button>
        </div>
      </article>

      <article id="Done" ondrop="drop(event, 'Done')" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
        <h2>Done</h2>
        <div class="add-task-inline">
            <input type="text" id="doneTaskInput" placeholder="New completed task title...">
            <button onclick="addInlineTask('Done', 'doneTaskInput')">Add</button>
        </div>
      </article>
    </section>
  </main>

  <div id="modalBackdrop" class="modal-backdrop hide"></div>
  <div id="taskModal" class="task-modal hide">
    <div class="modal-header">
      <h2 id="modalTitleText">Add New Task</h2>
      <button class="modal-close-button" onclick="closeModal()">√ó</button>
    </div>
    <form class="modal-form" onsubmit="event.preventDefault(); saveTaskChanges();">
      <input type="hidden" id="taskId">
      <input type="hidden" id="taskCurrentStatus">
      <input type="hidden" id="taskTimestamp">
      <input type="hidden" id="taskIsArchived">

      <label for="taskTitle">Title:</label>
      <input type="text" id="taskTitle" required>

      <label for="taskDescription">Description:</label>
      <textarea id="taskDescription" required></textarea>

      <label for="taskNotes">Notes:</label>
      <textarea id="taskNotes"></textarea>

      <label for="taskCategory">Category:</label>
      <select id="taskCategory" required>
        <option value="">Select Category</option>
        <option value="Development">Development</option>
        <option value="Design">Design</option>
        <option value="Marketing">Marketing</option>
        <option value="Sales">Sales</option>
        <option value="Support">Support</option>
        <option value="Testing">Testing</option>
        <option value="General">General</option>
      </select>

      <label for="taskPriority">Priority:</label>
      <select id="taskPriority" required>
        <option value="">Select Priority</option>
        <option value="High">High</option>
        <option value="Medium">Medium</option>
        <option value="Low">Low</option>
      </select>

      <label for="taskDueDate">Due Date:</label>
      <input type="date" id="taskDueDate">

      <label for="taskProgress">Progress (%):</label>
      <input type="number" id="taskProgress" min="0" max="100" value="0">

      <label for="taskAssignedTo">Assigned To:</label>
      <input type="text" id="taskAssignedTo">

      <label for="taskEstimatedCost">Estimated Cost ($):</label>
      <input type="number" id="taskEstimatedCost" min="0" step="0.01">

      <div class="modal-actions">
        <button type="button" class="modal-button cancel" onclick="closeModal()">Cancel</button>
        <button type="submit" class="modal-button action" id="modalActionButton">Create Task</button>
      </div>
    </form>
  </div>

  <div id="snackbar" class="snackbar"></div>

  <script>
    let tasks = []; // Tasks will now be fetched from Google Sheet

    // Chart instances
    let taskStatusChart;
    let taskPriorityChart;
    let taskCategoryChart;

    // >>>>>>>>>>>>>> IMPORTANT: REPLACE THIS WITH YOUR DEPLOYED GOOGLE APPS SCRIPT WEB APP URL <<<<<<<<<<<<<<<
    const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycby1HwauAkIiHdFuBSfrrQJiKqw3ZTlKxnBWe3XOVGib4G06vF5i-aXYn3tqLvexj6Af/exec';
    // Example: const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbu9u_YOUR_ID_HERE_g/exec';
    // Make sure it ends with /exec
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

    // --- Utility Functions ---

    function showSnackbar(message, isError = false) {
        let snackbar = document.getElementById('snackbar');
        if (!snackbar) {
            const newSnackbar = document.createElement('div');
            newSnackbar.id = 'snackbar';
            document.body.appendChild(newSnackbar);
            snackbar = newSnackbar;
        }
        snackbar.textContent = message;
        snackbar.className = 'snackbar ' + (isError ? 'error' : 'show');
        setTimeout(() => {
            snackbar.className = snackbar.className.replace('show', '');
            if (isError) snackbar.className = snackbar.className.replace('error', '');
        }, 3000);
    }

    // --- Google Apps Script Communication using Fetch API ---

    async function fetchTasks() {
      try {
        const response = await fetch(APPS_SCRIPT_URL);
        const data = await response.json();

        if (data.error) {
          console.error("Error fetching tasks:", data.error, data.stack);
          showSnackbar("Error fetching tasks: " + data.error, true);
          tasks = []; // Clear tasks on error
        } else {
          tasks = data;
          populateAssignedToFilter();
          renderTasks();
          showSnackbar("Tasks loaded from Google Sheet.");
        }
      } catch (error) {
        console.error("Fetch Error (fetchTasks):", error);
        showSnackbar("Failed to load tasks: " + error.message, true);
        tasks = []; // Clear tasks on error
        renderTasks(); // Render to show empty state
      }
    }

    async function sendTaskAction(action, taskData, rowIndex = null) {
        try {
            const payload = { action, task: taskData };
            if (rowIndex !== null) {
                payload.rowIndex = rowIndex;
            }

            const response = await fetch(APPS_SCRIPT_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            const data = await response.json();

            if (data.success) {
                // Re-fetch all tasks to ensure UI is in sync with sheet after modification
                // For better UX, you could also just update the local 'tasks' array
                // but re-fetching ensures full consistency.
                await fetchTasks();
                showSnackbar(data.message);
                closeModal(); // Close modal on successful operation
            } else {
                console.error(`Error ${action}ing task:`, data.error, data.stack);
                showSnackbar(`Error ${action}ing task: ` + data.error, true);
            }
        } catch (error) {
            console.error(`Fetch Error (${action}Task):`, error);
            showSnackbar(`Failed to ${action} task: ` + error.message, true);
        }
    }

    function updateTaskOnSheet(taskData, rowIndex) {
        sendTaskAction('update', taskData, rowIndex);
    }

    function createTaskOnSheet(taskData) {
        sendTaskAction('create', taskData);
    }

    function deleteTaskOnSheet(rowIndex) {
        sendTaskAction('delete', null, rowIndex); // No taskData needed for delete
    }


    // --- Modal & Task Data Handling ---

    function populateTaskModal(task) {
        document.getElementById('modalTitleText').textContent = task.OriginalIndex === undefined ? 'Add New Task' : 'Edit Task';
        document.getElementById('taskId').value = task.OriginalIndex !== undefined ? task.OriginalIndex : '';
        document.getElementById('taskTitle').value = task.Title || '';
        document.getElementById('taskDescription').value = task.Description || '';
        document.getElementById('taskNotes').value = task.Notes || ''; // Populate Notes field
        document.getElementById('taskCategory').value = task.Category || '';
        document.getElementById('taskPriority').value = task.Priority || '';
        document.getElementById('taskDueDate').value = task.DueDate || '';
        document.getElementById('taskProgress').value = task.Progress !== undefined ? task.Progress : 0;
        document.getElementById('taskAssignedTo').value = task.AssignedTo || '';
        document.getElementById('taskEstimatedCost').value = task.EstimatedCost !== undefined ? task.EstimatedCost : '';

        // Store current status, timestamp, and archive status in hidden fields
        document.getElementById('taskCurrentStatus').value = task.Status || '';
        document.getElementById('taskTimestamp').value = task.Timestamp || '';
        document.getElementById('taskIsArchived').value = task.IsArchived ? 'true' : 'false';
    }

    function getTaskDataFromModal() {
        const originalIndex = document.getElementById('taskId').value !== '' ? parseInt(document.getElementById('taskId').value) : undefined;
        const title = document.getElementById('taskTitle').value.trim();
        const description = document.getElementById('taskDescription').value.trim();
        const notes = document.getElementById('taskNotes').value.trim(); // Get value from Notes textarea
        const category = document.getElementById('taskCategory').value.trim();
        const priority = document.getElementById('taskPriority').value.trim();
        const dueDate = document.getElementById('taskDueDate').value;
        let progress = parseInt(document.getElementById('taskProgress').value, 10);
        const assignedTo = document.getElementById('taskAssignedTo').value.trim();
        let estimatedCost = parseFloat(document.getElementById('taskEstimatedCost').value);

        // Get status, timestamp, and archive status from hidden fields for existing tasks
        const currentStatus = document.getElementById('taskCurrentStatus').value;
        const timestamp = document.getElementById('taskTimestamp').value;
        const isArchived = document.getElementById('taskIsArchived').value === 'true';

        return {
            OriginalIndex: originalIndex,
            Title: title,
            Description: description,
            Notes: notes,
            Category: category,
            Priority: priority,
            Status: currentStatus, // Use current status from hidden field
            DueDate: dueDate,
            Progress: isNaN(progress) ? 0 : progress,
            AssignedTo: assignedTo,
            EstimatedCost: isNaN(estimatedCost) || estimatedCost < 0 ? 0 : estimatedCost,
            Timestamp: timestamp || new Date().toISOString(), // Use existing timestamp or new one
            IsArchived: isArchived // Use existing archive status
        };
    }


    function openModal(status, originalIndex = null) {
      const modalBackdrop = document.getElementById("modalBackdrop");
      const taskModal = document.getElementById("taskModal");

      modalBackdrop.classList.remove('hide');
      taskModal.classList.remove('hide');

      modalBackdrop.style.display = 'block';
      taskModal.style.display = 'block';

      modalBackdrop.classList.add('show');
      taskModal.classList.add('show');

      const modalActionButton = document.getElementById("modalActionButton");
      if (originalIndex !== null) {
        const task = tasks.find(t => t.OriginalIndex === originalIndex);
        if (task) {
            populateTaskModal(task);
            modalActionButton.textContent = "Update Task";
        } else {
            console.error("Task not found for editing with OriginalIndex:", originalIndex);
            showSnackbar("Error: Task not found for editing.", true);
            closeModal();
        }
      } else {
        // Clear fields for new task
        document.getElementById("taskId").value = "";
        document.getElementById("taskTitle").value = "";
        document.getElementById("taskDescription").value = "";
        document.getElementById("taskNotes").value = ""; // Clear Notes
        document.getElementById("taskCategory").value = "";
        document.getElementById("taskPriority").value = "";
        document.getElementById("taskDueDate").value = "";
        document.getElementById("taskProgress").value = 0;
        document.getElementById("taskAssignedTo").value = "";
        document.getElementById("taskEstimatedCost").value = "";
        document.getElementById("taskCurrentStatus").value = status; // Set initial status for new task
        document.getElementById("taskTimestamp").value = ""; // Clear timestamp
        document.getElementById("taskIsArchived").value = "false"; // New tasks are not archived

        document.getElementById("modalTitleText").textContent = "Create Task";
        modalActionButton.textContent = "Create Task";
      }
    }

    function closeModal() {
      const modalBackdrop = document.getElementById("modalBackdrop");
      const taskModal = document.getElementById("taskModal");

      modalBackdrop.classList.remove('show');
      modalBackdrop.classList.add('hide');
      taskModal.classList.remove('show');
      taskModal.classList.add('hide');

      let backdropAnimationEnded = false;
      let modalAnimationEnded = false;

      const checkAndHide = () => {
        if (backdropAnimationEnded && modalAnimationEnded) {
          taskModal.style.display = 'none';
          modalBackdrop.style.display = 'none';

          // Clear all modal fields after closing
          document.getElementById("taskId").value = "";
          document.getElementById("taskTitle").value = "";
          document.getElementById("taskDescription").value = "";
          document.getElementById("taskNotes").value = "";
          document.getElementById("taskCategory").value = "";
          document.getElementById("taskPriority").value = "";
          document.getElementById("taskDueDate").value = "";
          document.getElementById("taskProgress").value = 0;
          document.getElementById("taskAssignedTo").value = "";
          document.getElementById("taskEstimatedCost").value = "";
          document.getElementById("taskCurrentStatus").value = "";
          document.getElementById("taskTimestamp").value = "";
          document.getElementById("taskIsArchived").value = "false";
        }
      };

      const backdropHandler = () => {
        backdropAnimationEnded = true;
        modalBackdrop.removeEventListener('animationend', backdropHandler);
        checkAndHide();
      };

      const modalHandler = () => {
        modalAnimationEnded = true;
        taskModal.removeEventListener('animationend', modalHandler);
        checkAndHide();
      };

      modalBackdrop.addEventListener('animationend', backdropHandler, { once: true });
      taskModal.addEventListener('animationend', modalHandler, { once: true });

      // Fallback in case animationend doesn't fire (e.g., if display was already none)
      setTimeout(() => {
        if (!backdropAnimationEnded || !modalAnimationEnded) {
          taskModal.style.display = 'none';
          modalBackdrop.style.display = 'none';
          document.getElementById("taskId").value = "";
          document.getElementById("taskTitle").value = "";
          document.getElementById("taskDescription").value = "";
          document.getElementById("taskNotes").value = "";
          document.getElementById("taskCategory").value = "";
          document.getElementById("taskPriority").value = "";
          document.getElementById("taskDueDate").value = "";
          document.getElementById("taskProgress").value = 0;
          document.getElementById("taskAssignedTo").value = "";
          document.getElementById("taskEstimatedCost").value = "";
          document.getElementById("taskCurrentStatus").value = "";
          document.getElementById("taskTimestamp").value = "";
          document.getElementById("taskIsArchived").value = "false";
        }
      }, 400); // Slightly longer than animation duration
    }


    function saveTaskChanges() {
      const taskData = getTaskDataFromModal();

      if (!taskData.Title || !taskData.Description || !taskData.Category || !taskData.Priority) {
        alert("Please fill out all required fields (Title, Description, Category, Priority).");
        return;
      }

      if (taskData.OriginalIndex !== undefined) {
        // Update existing task
        updateTaskOnSheet(taskData, taskData.OriginalIndex);
      } else {
        // Create new task
        createTaskOnSheet(taskData);
      }
    }

    // Add task directly from inline input
    function addInlineTask(status, inputId) {
      const inputField = document.getElementById(inputId);
      const title = inputField.value.trim();

      if (!title) {
        alert("Please enter a task title.");
        return;
      }

      const taskData = {
        Title: title,
        Description: "",
        Notes: "", // Default empty notes
        Category: "General", // Default category for quick add
        Priority: "Low", // Default to low priority for quick add
        Status: status,
        DueDate: "",
        Progress: 0,
        AssignedTo: "",
        EstimatedCost: 0,
        IsArchived: false
      };

      createTaskOnSheet(taskData);
      inputField.value = ""; // Clear input field after sending
    }


    function editTask(originalIndex) {
      openModal(null, originalIndex); // Pass null for status as it's an edit, originalIndex is key
    }

    function removeTask(originalIndex) {
      if (confirm("Are you sure you want to permanently delete this task? This action cannot be undone.")) {
        const taskElement = document.getElementById(`task-${originalIndex}`);
        if (taskElement) {
          taskElement.style.animation = 'popOut 0.3s ease-in forwards';
          taskElement.addEventListener('animationend', () => {
            deleteTaskOnSheet(originalIndex);
          }, { once: true });
        } else {
          deleteTaskOnSheet(originalIndex);
        }
      }
    }

    // Function to toggle archive status
    function toggleArchiveTask(originalIndex) {
      const task = tasks.find(t => t.OriginalIndex === originalIndex);
      if (!task) {
          showSnackbar("Error: Task not found for archiving.", true);
          return;
      }

      const newArchiveStatus = !task.IsArchived;
      const action = newArchiveStatus ? "archive" : "unarchive";

      if (confirm(`Are you sure you want to ${action} this task?`)) {
        const updatedTaskData = { ...task, IsArchived: newArchiveStatus };
        // If unarchived and in 'Done' status, ensure progress is 100%
        if (!newArchiveStatus && updatedTaskData.Status === 'Done') {
            updatedTaskData.Progress = 100;
        }
        updateTaskOnSheet(updatedTaskData, originalIndex);
      }
    }


    function getPriorityIcon(priority) {
      return priority === "High" ? "üî¥"
           : priority === "Medium" ? "üü°"
           : priority === "Low" ? "üü¢"
           : "";
    }

    function formatTimestamp(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      return date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: true
      });
    }

    function getProgressColor(priority) {
      switch (priority) {
        case 'High':
          return 'var(--color-progress-high)';
        case 'Medium':
          return 'var(--color-progress-medium)';
        case 'Low':
        default:
          return 'var(--color-progress-low)';
      }
    }

    function getSubtleTaskBackgroundColor(priority) {
      switch (priority) {
        case 'High':
          return 'rgba(176, 58, 46, 0.15)';
        case 'Medium':
          return 'rgba(212, 172, 13, 0.15)';
        case 'Low':
        default:
          return 'rgba(39, 174, 174, 0.15)';
      }
    }

    function isOverdue(dueDate, status) {
        if (!dueDate || status === 'Done') return false;
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Normalize today to start of day
        const due = new Date(dueDate);
        due.setHours(0, 0, 0, 0); // Normalize due date to start of day
        return due < today;
    }


    function renderTasks() {
      const search = document.getElementById("searchInput").value.trim().toLowerCase();
      const categoryFilterValue = document.getElementById("categoryFilter").value.trim();
      const priorityFilterValue = document.getElementById("priorityFilter").value.trim();
      const assignedToFilterValue = document.getElementById("assignedToFilter").value.trim();
      const showArchived = document.getElementById("showArchivedCheckbox").checked;

      ["Pending", "In Progress", "Done"].forEach(status => {
        document.getElementById(status).innerHTML = "";
        document.getElementById(status).closest('article').classList.remove('drag-over');
      });

      const filteredTasks = [];
      tasks.forEach(task => { // tasks array is already from sheet, no need for originalIndex here
        const shouldRender = (!task.IsArchived || showArchived);

        if (!shouldRender) {
            return;
        }

        const taskTitle = task.Title || "";
        const taskDescription = task.Description || "";
        const taskCategory = task.Category || "";
        const taskPriority = task.Priority || "";
        const taskAssignedTo = task.AssignedTo || "";
        const taskStatus = task.Status || "";

        const matchesSearch = search === "" ||
          taskTitle.toLowerCase().includes(search) ||
          taskDescription.toLowerCase().includes(search) ||
          task.Notes.toLowerCase().includes(search); // Include Notes in search

        const matchesCategory = categoryFilterValue === "" || taskCategory === categoryFilterValue;
        const matchesPriority = priorityFilterValue === "" || taskPriority === priorityFilterValue;
        const matchesAssignedTo = assignedToFilterValue === "" || taskAssignedTo === assignedToFilterValue;

        if (matchesSearch && matchesCategory && matchesPriority && matchesAssignedTo) {
          filteredTasks.push(task); // Push the task object itself
        }
      });


      filteredTasks.forEach(task => {
        const taskTitle = task.Title || "Untitled";
        const taskDescription = task.Description || "No description.";
        const taskNotes = task.Notes || ""; // Get Notes
        const taskCategory = task.Category || "Uncategorized";
        const taskPriority = task.Priority || "Low";
        const taskDueDate = task.DueDate ? `üìÖ Due: ${task.DueDate}` : '';
        const taskProgress = task.Progress !== undefined ? task.Progress : 0;
        const taskTimestamp = task.Timestamp ? formatTimestamp(task.Timestamp) : '';
        const taskLastModified = task.LastModified ? formatTimestamp(task.LastModified) : ''; // Get Last Modified
        const taskAssignedTo = task.AssignedTo ? `üßë‚Äçüíª Assigned: ${task.AssignedTo}` : '';
        const taskEstimatedCost = task.EstimatedCost !== undefined && task.EstimatedCost > 0 ? `üí∞ Est. Cost: $${task.EstimatedCost.toLocaleString()}` : '';

        const el = document.createElement("div");
        el.id = `task-${task.OriginalIndex}`; // Use OriginalIndex from backend
        const categoryClass = (task.Category || "Uncategorized").replace(/\s/g, '\\ ');
        const priorityClass = (task.Priority || "Low");

        el.className = `task-card ${categoryClass} ${priorityClass}`; // Changed to task-card
        el.draggable = true;
        el.ondragstart = e => dragStart(e, task.OriginalIndex); // Use OriginalIndex

        const subtleTaskBg = getSubtleTaskBackgroundColor(taskPriority);
        let progressFillColor = getProgressColor(taskPriority);

        el.style.backgroundColor = subtleTaskBg;

        if (taskProgress === 0) {
          el.style.backgroundImage = 'none';
        } else if (taskProgress === 100) {
           el.style.backgroundColor = progressFillColor;
           el.style.backgroundImage = 'none';
        } else {
          el.style.backgroundImage = `linear-gradient(to right, ${progressFillColor} ${taskProgress}%, ${subtleTaskBg} ${taskProgress}%)`;
        }

        const progressText = (task.Status === "Done" && taskProgress === 100) ? `‚úÖ Done!` : `üìä Progress: ${taskProgress}%`;

        // Apply overdue style
        if (isOverdue(task.DueDate, task.Status)) {
            el.classList.add('overdue');
        } else {
            el.classList.remove('overdue');
        }

        el.innerHTML = `
          <div>
              <div class="task-header">
                  <h3>${taskTitle}</h3>
                  <div class="task-actions">
                      <button class="icon-button edit-button" onclick="editTask(${task.OriginalIndex})">‚úèÔ∏è</button>
                      <button class="icon-button delete-button" onclick="removeTask(${task.OriginalIndex})">üóëÔ∏è</button>
                  </div>
              </div>
              <p class="task-description">${taskDescription || 'No description provided.'}</p>
              ${taskNotes ? `<p class="task-notes"><strong>Notes:</strong> ${taskNotes}</p>` : ''}
          </div>
          <div class="task-meta-details">
              <span>${getPriorityIcon(taskPriority)} ${taskPriority}</span>
              <span>${taskCategory}</span>
              ${taskAssignedTo ? `<span>${taskAssignedTo}</span>` : ''}
              ${taskEstimatedCost ? `<span>${taskEstimatedCost}</span>` : ''}
          </div>
          <div class="task-info">
              <span class="task-progress-text">${progressText}</span>
              ${taskDueDate ? `<span>${taskDueDate}</span>` : ''}
              <div class="task-dates">
                  ${taskTimestamp ? `<span>Created: ${taskTimestamp}</span>` : ''}
                  ${taskLastModified ? `<span class="last-modified">Modified: ${taskLastModified}</span>` : ''}
              </div>
              <button onclick="toggleArchiveTask(${task.OriginalIndex})" title="Toggle Archive Status">üóÑÔ∏è ${task.IsArchived ? 'Unarchive' : 'Archive'}</button>
          </div>
        `;

        const targetColumn = document.getElementById(task.Status); // Use task.Status
        if (targetColumn) {
            targetColumn.appendChild(el);
        }
      });


      // Calculate and display overall progress correctly, ignoring archived tasks for this count
      const nonArchivedTasks = tasks.filter(task => !task.IsArchived);
      const totalActualTasks = nonArchivedTasks.length;
      const completedActualTasks = nonArchivedTasks.filter(task => task.Status === "Done").length;

      document.getElementById("progressMessage").textContent =
        totalActualTasks > 0
          ? `‚úÖ ${completedActualTasks} of ${totalActualTasks} tasks completed`
          : "üìã No active tasks yet ‚Äî add one to get started";

      // Update charts and health status
      updateTaskCharts();
      updateOverdueCount();
    }


    function dragStart(event, originalIndex) {
      event.dataTransfer.setData("text/plain", originalIndex); // Use originalIndex for data transfer
    }

    function allowDrop(event) {
      event.preventDefault();
      if (event.target.closest('article')) {
        event.target.closest('article').classList.add('drag-over');
      }
    }

    function dragLeave(event) {
      if (event.target.closest('article')) {
        event.target.closest('article').classList.remove('drag-over');
      }
    }

    function drop(event, newStatus) {
      event.preventDefault();
      const originalIndex = parseInt(event.dataTransfer.getData("text/plain"), 10); // Parse to int

      document.querySelectorAll('article').forEach(article => {
        article.classList.remove('drag-over');
      });

      const taskToUpdate = tasks.find(t => t.OriginalIndex === originalIndex);
      if (taskToUpdate) {
        const oldStatus = taskToUpdate.Status;
        taskToUpdate.Status = newStatus;

        if (newStatus === 'Done') {
            taskToUpdate.Progress = 100;
            taskToUpdate.IsArchived = false; // Unarchive if moved to Done
        } else if (oldStatus === 'Done' && newStatus !== 'Done') {
            taskToUpdate.Progress = Math.min(taskToUpdate.Progress, 99); // Set to max 99 if moved out of done
            taskToUpdate.IsArchived = false; // Unarchive if moved out of Done
        }

        updateTaskOnSheet(taskToUpdate, originalIndex); // Send updated task to backend
      }
    }

    function exportToExcel() {
      if (tasks.length === 0) {
        alert("No tasks to export!");
        return;
      }

      const exportTasks = tasks.map(task => ({
          Title: task.Title,
          Description: task.Description,
          Notes: task.Notes,
          Category: task.Category,
          Priority: task.Priority,
          Status: task.Status,
          DueDate: task.DueDate,
          Progress: task.Progress,
          AssignedTo: task.AssignedTo,
          EstimatedCost: task.EstimatedCost,
          CreatedTimestamp: formatTimestamp(task.Timestamp),
          LastModifiedTimestamp: formatTimestamp(task.LastModified),
          IsArchived: task.IsArchived ? 'Yes' : 'No'
      }));


      const ws = XLSX.utils.json_to_sheet(exportTasks);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Tasks");
      XLSX.writeFile(wb, "NeonCivilDashboard_Tasks.xlsx");
    }

    // Populate Assigned To filter dropdown
    function populateAssignedToFilter() {
      const assignedToFilter = document.getElementById('assignedToFilter');
      assignedToFilter.innerHTML = '<option value="">Filter by Assignee</option>'; // Reset
      const assignees = new Set();
      tasks.forEach(task => {
        if (task.AssignedTo) {
          assignees.add(task.AssignedTo);
        }
      });
      Array.from(assignees).sort().forEach(assignee => {
        const option = document.createElement('option');
        option.value = assignee;
        option.textContent = assignee;
        assignedToFilter.appendChild(option);
      });
    }

    // *** Chart.js Functions ***
    function updateTaskCharts() {
        const activeTasks = tasks.filter(task => !task.IsArchived);

        // Data for Status Chart
        const statusCounts = activeTasks.reduce((acc, task) => {
            acc[task.Status] = (acc[task.Status] || 0) + 1;
            return acc;
        }, {});
        const statusLabels = ["Pending", "In Progress", "Done"];
        const statusData = statusLabels.map(label => statusCounts[label] || 0);
        const statusColors = ['#F6AD55', '#63B3ED', '#4FD1C5']; // Orange, Blue, Teal

        // Data for Priority Chart
        const priorityCounts = activeTasks.reduce((acc, task) => {
            acc[task.Priority] = (acc[task.Priority] || 0) + 1;
            return acc;
        }, {});
        const priorityLabels = ["High", "Medium", "Low"];
        const priorityData = priorityLabels.map(label => priorityCounts[label] || 0);
        const priorityColors = ['#E53E3E', '#ECC94B', '#4FD1C5']; // Red, Yellow, Teal

        // Data for Category Chart
        const categoryCounts = activeTasks.reduce((acc, task) => {
            if (task.Category) {
                acc[task.Category] = (acc[task.Category] || 0) + 1;
            }
            return acc;
        }, {});
        const categoryLabels = Object.keys(categoryCounts).sort();
        const categoryData = categoryLabels.map(label => categoryCounts[label]);
        const categoryColors = categoryLabels.map((_, i) => `hsl(${i * 60 % 360}, 70%, 50%)`); // Dynamic colors


        // Common chart options to squeeze space
        const commonChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: {
                        color: '#FFFFFF', // Set legend text color to explicit white for visibility
                        padding: 8 // Reduced padding around legend items
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed !== null) {
                                label += context.parsed;
                            }
                            return label;
                        }
                    }
                }
            },
            layout: {
                padding: {
                    left: 5, // Reduced padding for the chart area itself
                    right: 5,
                    top: 5,
                    bottom: 5
                }
            }
        };


        // Initialize or Update Task Status Chart
        const ctxStatus = document.getElementById('taskStatusChart').getContext('2d');
        if (taskStatusChart) {
            taskStatusChart.data.labels = statusLabels;
            taskStatusChart.data.datasets[0].data = statusData;
            taskStatusChart.data.datasets[0].backgroundColor = statusColors;
            taskStatusChart.update();
        } else {
            taskStatusChart = new Chart(ctxStatus, {
                type: 'pie',
                data: {
                    labels: statusLabels,
                    datasets: [{
                        data: statusData,
                        backgroundColor: statusColors,
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 1
                    }]
                },
                options: commonChartOptions // Apply common options
            });
        }

        // Initialize or Update Task Priority Chart
        const ctxPriority = document.getElementById('taskPriorityChart').getContext('2d');
        if (taskPriorityChart) {
            taskPriorityChart.data.labels = priorityLabels;
            taskPriorityChart.data.datasets[0].data = priorityData;
            taskPriorityChart.data.datasets[0].backgroundColor = priorityColors;
            taskPriorityChart.update();
        } else {
            taskPriorityChart = new Chart(ctxPriority, {
                type: 'pie',
                data: {
                    labels: priorityLabels,
                    datasets: [{
                        data: priorityData,
                        backgroundColor: priorityColors,
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 1
                    }]
                },
                options: commonChartOptions // Apply common options
            });
        }

        // Initialize or Update Task Category Chart
        const ctxCategory = document.getElementById('taskCategoryChart').getContext('2d');
        if (taskCategoryChart) {
            taskCategoryChart.data.labels = categoryLabels;
            taskCategoryChart.data.datasets[0].data = categoryData;
            taskCategoryChart.data.datasets[0].backgroundColor = categoryColors;
            taskCategoryChart.update();
        } else {
            taskCategoryChart = new Chart(ctxCategory, {
                type: 'pie',
                data: {
                    labels: categoryLabels,
                    datasets: [{
                        data: categoryData,
                        backgroundColor: categoryColors,
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 1
                    }]
                },
                options: commonChartOptions // Apply common options
            });
        }
    }

    // Function to update the overdue task count
    function updateOverdueCount() {
        const overdueTasks = tasks.filter(task => !task.IsArchived && isOverdue(task.DueDate, task.Status));
        document.getElementById('overdueCount').textContent = overdueTasks.length;
    }


    // Initial calls when the script loads
    document.addEventListener('DOMContentLoaded', fetchTasks); // Fetch tasks from Google Sheet on load
  </script>
</body>
</html>
